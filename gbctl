#!/usr/bin/env bash

# GreedyBear Setup and Management Script
# This script simplifies deployment, updates, and management of GreedyBear instances

set -e

# Version and defaults
GREEDYBEAR_VERSION="latest"
PROJECT_NAME="greedybear"
DOCKER_COMPOSE_MIN_VERSION="2.0.0"
SILENT_MODE=false

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Environment and command validation arrays
declare -A env_arguments=(["prod"]=1 ["dev"]=1 ["test"]=1)
declare -A cmd_arguments=(["init"]=1 ["up"]=1 ["start"]=1 ["down"]=1 ["stop"]=1 ["restart"]=1 ["logs"]=1 ["ps"]=1 ["update"]=1 ["build"]=1 ["pull"]=1 ["backup"]=1 ["restore"]=1 ["health"]=1 ["clean"]=1)

# Path mapping for compose files
declare -A path_mapping=(
    ["default"]="docker/default.yml"
    ["local"]="docker/local.override.yml"
    ["https"]="docker/https.override.yml"
    ["elastic"]="docker/elasticsearch.yml"
    ["stag"]="docker/stag.override.yml"
    ["version"]="docker/version.override.yml"
)

# Logging functions
log_info() {
    if [ "$SILENT_MODE" = false ]; then
        echo -e "${BLUE}[INFO]${NC} $1"
    fi
}

log_success() {
    if [ "$SILENT_MODE" = false ]; then
        echo -e "${GREEN}[SUCCESS]${NC} $1"
    fi
}

log_warning() {
    if [ "$SILENT_MODE" = false ]; then
        echo -e "${YELLOW}[WARNING]${NC} $1"
    fi
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

# Print help message
print_help() {
    cat << EOF
GreedyBear - Automated Setup and Management Script

SYNOPSIS
    ./gbctl <command> [OPTIONS]
    ./gbctl -h|--help

COMMANDS
    init         Initialize GreedyBear (setup environment files)
    up           Start all services
    start        Alias for 'up'
    down         Stop and remove all services
    stop         Stop all services without removing them
    restart      Restart all services
    logs         View logs from services
    ps           List running services
    update       Update GreedyBear to latest version
    build        Build Docker images
    pull         Pull latest Docker images
    backup       Backup database and volumes
    restore      Restore from backup
    health       Health check all services
    clean        Remove all data and reset (destructive!)

OPTIONS
    -h, --help              Show this help message
    -s, --silent            Silent mode (non-interactive)
    --project-name <name>   Specify project name (default: greedybear)
    --version <value>       Specify version to install (default: latest)
    
DEPLOYMENT FLAGS
    --prod                  Production deployment (default)
    --dev                   Development deployment with hot-reload
    --test                  Test deployment
    
FEATURE FLAGS
    --https                 Enable HTTPS with custom certificates
    --elastic               Enable Elasticsearch (requires >=16GB RAM)
    --stag                  Staging deployment configuration
    --use-version           Use specific version override

EXAMPLES
    # Initialize and start production deployment
    ./gbctl init --prod
    ./gbctl up --prod

    # Development with Elasticsearch
    ./gbctl up --dev --elastic

    # Update production instance
    ./gbctl update --prod

    # View logs
    ./gbctl logs

    # Silent installation (non-interactive)
    ./gbctl init --prod --silent

EOF
}

# Check if Docker is installed
check_docker() {
    log_info "Checking Docker installation..."
    
    if ! command -v docker &> /dev/null; then
        log_error "Docker is not installed."
        if [ "$SILENT_MODE" = false ]; then
            read -p "Would you like to install Docker? [y/N] " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                install_docker
            else
                log_error "Docker is required to run GreedyBear. Exiting."
                exit 1
            fi
        else
            log_error "Please install Docker first. Visit: https://docs.docker.com/get-docker/"
            exit 1
        fi
    else
        DOCKER_VERSION=$(docker --version | cut -d ' ' -f3 | tr -d ',')
        log_success "Docker ${DOCKER_VERSION} is installed"
    fi
}

# Check if Docker Compose is installed
check_docker_compose() {
    log_info "Checking Docker Compose installation..."
    
    if ! docker compose version &> /dev/null; then
        log_error "Docker Compose v2+ is not available."
        if [ "$SILENT_MODE" = false ]; then
            read -p "Would you like installation instructions? [y/N] " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                echo "Please install Docker Compose v2+: https://docs.docker.com/compose/install/"
            fi
        fi
        exit 1
    else
        COMPOSE_VERSION=$(docker compose version --short)
        log_success "Docker Compose ${COMPOSE_VERSION} is installed"
    fi
}

# Install Docker (support for multiple distros)
install_docker() {
    log_info "Installing Docker..."
    
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        case $ID in
            ubuntu|debian)
                curl -fsSL https://get.docker.com -o get-docker.sh
                sudo sh get-docker.sh
                sudo usermod -aG docker "$USER"
                rm get-docker.sh
                log_success "Docker installed. Please log out and back in for group changes to take effect."
                ;;
            fedora)
                sudo dnf -y install dnf-plugins-core
                sudo dnf config-manager --add-repo https://download.docker.com/linux/fedora/docker-ce.repo
                sudo dnf install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
                sudo systemctl start docker
                sudo systemctl enable docker
                sudo usermod -aG docker "$USER"
                log_success "Docker installed. Please log out and back in for group changes to take effect."
                ;;
            centos|rhel|almalinux|rocky)
                sudo yum install -y yum-utils
                sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
                sudo yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
                sudo systemctl start docker
                sudo systemctl enable docker
                sudo usermod -aG docker "$USER"
                log_success "Docker installed. Please log out and back in for group changes to take effect."
                ;;
            opensuse*|sles)
                sudo zypper install -y docker docker-compose
                sudo systemctl start docker
                sudo systemctl enable docker
                sudo usermod -aG docker "$USER"
                log_success "Docker installed. Please log out and back in for group changes to take effect."
                ;;
            *)
                log_error "Automatic installation not supported for $ID"
                log_info "Please install Docker manually:"
                log_info "  Visit: https://docs.docker.com/get-docker/"
                exit 1
                ;;
        esac
    else
        log_error "Cannot detect OS. Please install Docker manually."
        log_info "Visit: https://docs.docker.com/get-docker/"
        exit 1
    fi
}

# Check system requirements
check_requirements() {
    log_info "Checking system requirements..."
    
    # Check available memory
    if command -v free &> /dev/null; then
        TOTAL_MEM=$(free -g | awk '/^Mem:/{print $2}')
        if [ "$ENABLE_ELASTIC" = true ] && [ "$TOTAL_MEM" -lt 16 ]; then
            log_warning "Elasticsearch requires at least 16GB RAM. You have ${TOTAL_MEM}GB."
            if [ "$SILENT_MODE" = false ]; then
                read -p "Continue anyway? [y/N] " -n 1 -r
                echo
                if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                    exit 1
                fi
            fi
        fi
    fi
    
    check_docker
    check_docker_compose
    
    log_success "All requirements met"
}

# Initialize environment files
init_env_files() {
    log_info "Initializing environment files..."
    
    # Handle env_file
    if [ -f docker/env_file ]; then
        if [ "$SILENT_MODE" = true ]; then
            log_info "Regenerating docker/env_file (silent mode)"
            cp docker/env_file_template docker/env_file
            log_success "Regenerated docker/env_file from template"
        else
            log_warning "docker/env_file already exists"
            read -p "Do you want to regenerate it? This will backup the existing file. [y/N] " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                mv docker/env_file docker/env_file.backup.$(date +%Y%m%d_%H%M%S)
                cp docker/env_file_template docker/env_file
                log_success "Backed up old file and created new docker/env_file from template"
            else
                log_info "Keeping existing docker/env_file"
            fi
        fi
    else
        if [ -f docker/env_file_template ]; then
            cp docker/env_file_template docker/env_file
            log_success "Created docker/env_file from template"
            
            if [ "$SILENT_MODE" = false ]; then
                log_warning "Please edit docker/env_file and configure required secrets:"
                log_warning "  - DJANGO_SECRET"
                log_warning "  - DB_PASSWORD"
                log_warning "  - DEFAULT_FROM_EMAIL"
                log_warning "  - DEFAULT_EMAIL"
            fi
        else
            log_error "docker/env_file_template not found"
            exit 1
        fi
    fi
    
    # Handle env_file_postgres
    if [ -f docker/env_file_postgres ]; then
        if [ "$SILENT_MODE" = true ]; then
            log_info "Regenerating docker/env_file_postgres (silent mode)"
            cp docker/env_file_postgres_template docker/env_file_postgres
            log_success "Regenerated docker/env_file_postgres from template"
        else
            log_info "docker/env_file_postgres already exists, skipping"
        fi
    else
        if [ -f docker/env_file_postgres_template ]; then
            cp docker/env_file_postgres_template docker/env_file_postgres
            log_success "Created docker/env_file_postgres from template"
        else
            log_error "docker/env_file_postgres_template not found"
            exit 1
        fi
    fi
    
    # Handle .env
    if [ -f .env ]; then
        if [ "$SILENT_MODE" = false ]; then
            log_info ".env already exists, skipping"
        fi
    else
        if [ -f .env_template ]; then
            cp .env_template .env
            log_success "Created .env from template"
        else
            log_warning ".env_template not found, skipping"
        fi
    fi
    
    # Generate Django secret if needed
    if [ "$SILENT_MODE" = false ]; then
        if grep -q "^DJANGO_SECRET=$" docker/env_file 2>/dev/null || grep -q "^DJANGO_SECRET=\"\"$" docker/env_file 2>/dev/null; then
            log_info "Generating Django secret key..."
            DJANGO_SECRET=$(openssl rand -base64 32 2>/dev/null || cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 50 | head -n 1)
            sed -i "s/^DJANGO_SECRET=.*/DJANGO_SECRET=${DJANGO_SECRET}/" docker/env_file
            log_success "Generated and set DJANGO_SECRET"
        fi
        
        # Generate database password if needed
        if grep -q "^DB_PASSWORD=password$" docker/env_file 2>/dev/null; then
            log_warning "Using default database password. Consider changing it in docker/env_file"
        fi
    fi
    
    log_success "Environment files initialized"
}

# Build compose file arguments
build_compose_args() {
    local compose_files=("${path_mapping["default"]}")
    
    # Add environment-specific files
    if [ "$ENV_MODE" = "dev" ]; then
        compose_files+=("${path_mapping["local"]}")
    fi
    
    # Add feature flags
    if [ "$ENABLE_HTTPS" = true ]; then
        compose_files+=("${path_mapping["https"]}")
    fi
    
    if [ "$ENABLE_ELASTIC" = true ]; then
        compose_files+=("${path_mapping["elastic"]}")
    fi
    
    if [ "$ENABLE_STAG" = true ]; then
        compose_files+=("${path_mapping["stag"]}")
    fi
    
    if [ "$USE_VERSION" = true ]; then
        compose_files+=("${path_mapping["version"]}")
    fi
    
    # Build docker compose arguments
    COMPOSE_ARGS=()
    for file in "${compose_files[@]}"; do
        if [ -n "$file" ] && [ -f "$file" ]; then
            COMPOSE_ARGS+=("-f" "$file")
        else
            log_warning "Compose file not found: $file"
        fi
    done
    
    COMPOSE_ARGS+=("-p" "$PROJECT_NAME")
}

# Execute docker compose command
execute_compose() {
    local cmd=$1
    shift
    
    build_compose_args
    
    log_info "Executing: docker compose ${COMPOSE_ARGS[*]} $cmd $*"
    
    if grep "docker" <<< "$(groups)" > /dev/null 2>&1; then
        docker compose --project-directory docker "${COMPOSE_ARGS[@]}" "$cmd" "$@"
    else
        sudo docker compose --project-directory docker "${COMPOSE_ARGS[@]}" "$cmd" "$@"
    fi
}

# Initialize GreedyBear
cmd_init() {
    log_info "Initializing GreedyBear..."
    
    check_requirements
    init_env_files
    
    log_success "Initialization complete!"
    echo
    log_info "Next steps:"
    if [ "$SILENT_MODE" = false ]; then
        log_info "  1. Review and configure docker/env_file with your settings"
        log_info "  2. Start GreedyBear with: ./start up --${ENV_MODE}"
    else
        log_info "  Start GreedyBear with: ./start up --${ENV_MODE}"
    fi
}

# Start services
cmd_up() {
    log_info "Starting GreedyBear services..."
    
    # Handle version checkout if specified
    if [ "$GREEDYBEAR_VERSION" != "latest" ] && [ "$ENV_MODE" = "prod" ]; then
        log_info "Checking out version ${GREEDYBEAR_VERSION}..."
        
        # Add current directory to git safe.directory if needed
        directory=$(git config --global --get safe.directory 2>/dev/null || true)
        if ! [[ "${directory}" == $(pwd) ]]; then
            git config --global --add safe.directory "$(pwd)"
        fi
        
        # Checkout the specified version
        if git rev-parse "v${GREEDYBEAR_VERSION}" >/dev/null 2>&1; then
            git checkout "v${GREEDYBEAR_VERSION}"
            log_success "Checked out version v${GREEDYBEAR_VERSION}"
        else
            log_error "Version v${GREEDYBEAR_VERSION} not found"
            log_info "Available versions:"
            git tag -l "v*" | tail -10
            exit 1
        fi
    fi
    
    execute_compose up -d "$@"
    log_success "GreedyBear is up and running!"
    
    if [ "$ENV_MODE" = "prod" ]; then
        if [ "$ENABLE_HTTPS" = true ]; then
            log_info "Access GreedyBear at: https://localhost"
        else
            log_info "Access GreedyBear at: http://localhost"
        fi
    else
        log_info "Access GreedyBear at: http://localhost"
    fi
}

# Stop and remove services
cmd_down() {
    log_info "Stopping GreedyBear services..."
    execute_compose down "$@"
    log_success "GreedyBear services stopped"
}

# Stop services
cmd_stop() {
    log_info "Stopping GreedyBear services..."
    execute_compose stop "$@"
    log_success "GreedyBear services stopped"
}

# Restart services
cmd_restart() {
    log_info "Restarting GreedyBear services..."
    execute_compose restart "$@"
    log_success "GreedyBear services restarted"
}

# View logs
cmd_logs() {
    execute_compose logs -f "$@"
}

# List services
cmd_ps() {
    execute_compose ps "$@"
}

# Update GreedyBear
cmd_update() {
    log_info "Updating GreedyBear..."
    
    # Pull latest images
    log_info "Pulling latest Docker images..."
    execute_compose pull
    
    # Restart services
    log_info "Restarting services with new images..."
    execute_compose up -d
    
    log_success "GreedyBear updated successfully!"
}

# Build images
cmd_build() {
    log_info "Building GreedyBear images..."
    execute_compose build "$@"
    log_success "Build complete"
}

# Pull images
cmd_pull() {
    log_info "Pulling GreedyBear images..."
    execute_compose pull "$@"
    log_success "Pull complete"
}

# Backup database and volumes
cmd_backup() {
    log_info "Creating backup..."
    
    local backup_dir="backups"
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_file="${backup_dir}/greedybear_backup_${timestamp}"
    
    mkdir -p "$backup_dir"
    
    # Check if postgres container is running
    if ! docker ps --format '{{.Names}}' | grep -q "greedybear_postgres"; then
        log_error "PostgreSQL container is not running. Start services first."
        exit 1
    fi
    
    # Backup PostgreSQL database
    log_info "Backing up PostgreSQL database..."
    docker exec greedybear_postgres pg_dump -U user greedybear_db > "${backup_file}.sql"
    
    if [ $? -eq 0 ]; then
        gzip "${backup_file}.sql"
        log_success "Database backup created: ${backup_file}.sql.gz"
    else
        log_error "Database backup failed"
        exit 1
    fi
    
    # Backup volumes info
    log_info "Saving volumes information..."
    docker volume ls --filter name=greedybear > "${backup_file}_volumes.txt"
    
    log_success "Backup complete: ${backup_file}.sql.gz"
    log_info "To restore: ./gbctl restore ${backup_file}.sql.gz"
}

# Restore from backup
cmd_restore() {
    if [ $# -eq 0 ]; then
        log_error "Please specify backup file to restore"
        log_info "Usage: ./gbctl restore backups/greedybear_backup_YYYYMMDD_HHMMSS.sql.gz"
        log_info "Available backups:"
        ls -lh backups/*.sql.gz 2>/dev/null || log_warning "No backups found"
        exit 1
    fi
    
    local backup_file=$1
    
    if [ ! -f "$backup_file" ]; then
        log_error "Backup file not found: $backup_file"
        exit 1
    fi
    
    # Check if postgres container is running
    if ! docker ps --format '{{.Names}}' | grep -q "greedybear_postgres"; then
        log_error "PostgreSQL container is not running. Start services first."
        exit 1
    fi
    
    if [ "$SILENT_MODE" = false ]; then
        log_warning "This will overwrite the current database!"
        read -p "Are you sure you want to restore from backup? [y/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            log_info "Restore cancelled"
            exit 0
        fi
    fi
    
    log_info "Restoring database from: $backup_file"
    
    # Decompress and restore
    if [[ $backup_file == *.gz ]]; then
        gunzip -c "$backup_file" | docker exec -i greedybear_postgres psql -U user greedybear_db
    else
        docker exec -i greedybear_postgres psql -U user greedybear_db < "$backup_file"
    fi
    
    if [ $? -eq 0 ]; then
        log_success "Database restored successfully"
    else
        log_error "Restore failed"
        exit 1
    fi
}

# Health check all services
cmd_health() {
    log_info "Checking GreedyBear services health..."
    echo
    
    # Get compose arguments
    build_compose_args
    
    # Check each service
    local services=("postgres" "uwsgi" "nginx" "rabbitmq" "celery_beat" "celery_worker_default")
    local all_healthy=true
    
    for service in "${services[@]}"; do
        local container_name="greedybear_${service}"
        
        if docker ps --format '{{.Names}}' | grep -q "^${container_name}$"; then
            local status=$(docker inspect --format='{{.State.Status}}' "$container_name" 2>/dev/null)
            local health=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}no healthcheck{{end}}' "$container_name" 2>/dev/null)
            
            if [ "$status" = "running" ]; then
                if [ "$health" = "healthy" ] || [ "$health" = "no healthcheck" ]; then
                    echo -e "${GREEN}✓${NC} $service: running"
                else
                    echo -e "${YELLOW}!${NC} $service: running (health: $health)"
                    all_healthy=false
                fi
            else
                echo -e "${RED}✗${NC} $service: $status"
                all_healthy=false
            fi
        else
            echo -e "${RED}✗${NC} $service: not running"
            all_healthy=false
        fi
    done
    
    echo
    if [ "$all_healthy" = true ]; then
        log_success "All services are healthy"
        return 0
    else
        log_warning "Some services have issues"
        log_info "Run './gbctl logs <service>' for details"
        return 1
    fi
}

# Clean all data and reset
cmd_clean() {
    log_warning "This will remove ALL GreedyBear data, containers, and volumes!"
    log_warning "This action is IRREVERSIBLE!"
    
    if [ "$SILENT_MODE" = false ]; then
        read -p "Type 'yes' to confirm complete removal: " confirmation
        if [ "$confirmation" != "yes" ]; then
            log_info "Clean cancelled"
            exit 0
        fi
    fi
    
    log_info "Stopping and removing all containers..."
    execute_compose down -v
    
    log_info "Removing environment files..."
    rm -f docker/env_file docker/env_file_postgres .env
    
    log_info "Removing backup directory..."
    rm -rf backups
    
    log_success "GreedyBear has been completely removed"
    log_info "To reinstall, run: ./gbctl init --prod"
}

# Parse arguments
parse_args() {
    # Set defaults
    ENV_MODE="prod"
    ENABLE_HTTPS=false
    ENABLE_ELASTIC=false
    ENABLE_STAG=false
    USE_VERSION=false
    COMMAND=""
    
    # Check for help
    if [[ $# -eq 0 ]] || [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
        print_help
        exit 0
    fi
    
    # First argument should be command
    if [[ ${cmd_arguments["$1"]} ]]; then
        COMMAND=$1
        shift
    else
        log_error "Invalid command: $1"
        print_help
        exit 1
    fi
    
    # Parse remaining arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --prod)
                ENV_MODE="prod"
                shift
                ;;
            --dev)
                ENV_MODE="dev"
                shift
                ;;
            --test)
                ENV_MODE="test"
                shift
                ;;
            --https)
                ENABLE_HTTPS=true
                shift
                ;;
            --elastic)
                ENABLE_ELASTIC=true
                shift
                ;;
            --stag)
                ENABLE_STAG=true
                shift
                ;;
            --use-version)
                USE_VERSION=true
                shift
                ;;
            --project-name)
                PROJECT_NAME=$2
                shift 2
                ;;
            --version)
                GREEDYBEAR_VERSION=$2
                shift 2
                ;;
            -s|--silent)
                SILENT_MODE=true
                shift
                ;;
            -h|--help)
                print_help
                exit 0
                ;;
            *)
                # Pass unknown args to docker compose
                break
                ;;
        esac
    done
    
    # Store remaining args for docker compose
    EXTRA_ARGS=("$@")
}

# Main execution
main() {
    parse_args "$@"
    
    # Execute command
    case $COMMAND in
        init)
            cmd_init "${EXTRA_ARGS[@]}"
            ;;
        up|start)
            cmd_up "${EXTRA_ARGS[@]}"
            ;;
        down)
            cmd_down "${EXTRA_ARGS[@]}"
            ;;
        stop)
            cmd_stop "${EXTRA_ARGS[@]}"
            ;;
        restart)
            cmd_restart "${EXTRA_ARGS[@]}"
            ;;
        logs)
            cmd_logs "${EXTRA_ARGS[@]}"
            ;;
        ps)
            cmd_ps "${EXTRA_ARGS[@]}"
            ;;
        update)
            cmd_update "${EXTRA_ARGS[@]}"
            ;;
        build)
            cmd_build "${EXTRA_ARGS[@]}"
            ;;
        pull)
            cmd_pull "${EXTRA_ARGS[@]}"
            ;;
        backup)
            cmd_backup "${EXTRA_ARGS[@]}"
            ;;
        restore)
            cmd_restore "${EXTRA_ARGS[@]}"
            ;;
        health)
            cmd_health "${EXTRA_ARGS[@]}"
            ;;
        clean)
            cmd_clean "${EXTRA_ARGS[@]}"
            ;;
        *)
            log_error "Unknown command: $COMMAND"
            print_help
            exit 1
            ;;
    esac
}

# Run main function
main "$@"
