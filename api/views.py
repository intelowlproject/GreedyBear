# This file is a part of GreedyBear https://github.com/honeynet/GreedyBear
# See the file 'LICENSE' for copying permission.
import csv
import logging
from datetime import datetime, timedelta

from api.serializers import EnrichmentSerializer, IOCSerializer
from certego_saas.apps.auth.backend import CookieTokenAuthentication
from certego_saas.ext.helpers import parse_humanized_range
from django.db.models import Count, Q
from django.db.models.functions import Trunc
from django.http import HttpResponse, HttpResponseBadRequest, HttpResponseServerError, JsonResponse, StreamingHttpResponse
from drf_spectacular.utils import extend_schema as add_docs
from drf_spectacular.utils import inline_serializer
from durin import views as durin_views
from greedybear.consts import FEEDS_LICENSE, GET, PAYLOAD_REQUEST, SCANNER
from greedybear.models import IOC, GeneralHoneypot, Statistics, viewType
from rest_framework import serializers as rfs
from rest_framework import status, viewsets
from rest_framework.decorators import action, api_view, authentication_classes, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response

logger = logging.getLogger(__name__)


class Echo:
    """An object that implements just the write method of the file-like
    interface.
    """

    def write(self, value):
        """Write the value by returning it, instead of storing in a buffer."""
        return value


# The Doc does not work as intended. We should refactor this by correctly leveraging DRF
@add_docs(description="Extract Structured IOC Feeds from GreedyBear")
@api_view([GET])
def feeds(request, feed_type, attack_type, age, format_):
    source = str(request.user)
    logger.info(f"request from {source}. Feed type: {feed_type}, attack_type: {attack_type}," f" Age: {age}, format: {format_}")

    feed_choices = ["log4j", "cowrie", "all"]
    generalHoneypots = GeneralHoneypot.objects.all().filter(active=True)
    feed_choices.extend([hp.name.lower() for hp in generalHoneypots])  # FEEDS

    if feed_type not in feed_choices:
        logger.info(f"Feed type {feed_type} not in feed_choises {feed_choices}")
        return _formatted_bad_request(format_)

    attack_types = ["scanner", "payload_request", "all"]
    if attack_type not in attack_types:
        return _formatted_bad_request(format_)

    age_choices = ["persistent", "recent"]
    if age not in age_choices:
        return _formatted_bad_request(format_)

    formats = ["csv", "json", "txt"]
    if format_ not in formats:
        return _formatted_bad_request(format_)

    query_dict = {}

    if feed_type != "all":
        # accept feed_type if it is in the general honeypots list
        if feed_type in [hp.name.lower() for hp in generalHoneypots]:
            query_dict["general__icontains"] = feed_type
        else:
            query_dict[feed_type] = True

    if attack_type != "all":
        query_dict[attack_type] = True

    if age == "recent":
        # everything in the last 3 days
        three_days_ago = datetime.utcnow() - timedelta(days=3)
        query_dict["last_seen__gte"] = three_days_ago
        iocs = IOC.objects.filter(**query_dict).order_by("-last_seen")[:5000]
    elif age == "persistent":
        # scanners detected in the last 14 days
        fourteen_days_ago = datetime.utcnow() - timedelta(days=14)
        query_dict["last_seen__gte"] = fourteen_days_ago
        # ... and at least detected 10 different days
        number_of_days_seen = 10
        query_dict["number_of_days_seen__gte"] = number_of_days_seen
        # order by the number of times seen
        iocs = IOC.objects.filter(**query_dict).order_by("-times_seen")[:1000]
    else:
        logger.error("this is impossible. check the code")
        return HttpResponseServerError()

    license_text = (
        f"# These feeds are generated by The Honeynet Project" f" once every 10 minutes and are protected" f" by the following license: {FEEDS_LICENSE}"
    )

    source_ip = str(request.META["REMOTE_ADDR"])
    request_source = Statistics(source=source_ip)
    request_source.save()

    if format_ == "txt":
        text_lines = [license_text]
        for ioc in iocs:
            text_lines.append(ioc.name)
        text = "\n".join(text_lines)
        return HttpResponse(text, content_type="text/plain")
    elif format_ == "csv":
        rows = []
        rows.append([license_text])
        for ioc in iocs:
            rows.append([ioc.name])
        pseudo_buffer = Echo()
        writer = csv.writer(pseudo_buffer, quoting=csv.QUOTE_NONE)
        return StreamingHttpResponse(
            (writer.writerow(row) for row in rows),
            content_type="text/csv",
            headers={"Content-Disposition": 'attachment; filename="feeds.csv"'},
            status=200,
        )
    elif format_ == "json":
        # json
        json_list = []
        for ioc in iocs:
            json_item = {
                "value": ioc.name,
                SCANNER: ioc.scanner,
                PAYLOAD_REQUEST: ioc.payload_request,
                "first_seen": ioc.first_seen.strftime("%Y-%m-%d"),
                "last_seen": ioc.last_seen.strftime("%Y-%m-%d"),
                "times_seen": ioc.times_seen,
            }
            json_list.append(json_item)
        return JsonResponse({"license": FEEDS_LICENSE, "iocs": json_list})
    else:
        logger.error("this is impossible. check the code")
        return HttpResponseServerError()


def _formatted_bad_request(format_):
    if format_ in ["csv", "txt"]:
        return HttpResponseBadRequest()
    else:
        # json
        return JsonResponse({}, status=400)


# The Doc does not work as intended. We should refactor this by correctly leveraging DRF
@add_docs(
    description="Request if a specific observable (domain or IP address) has been listed by GreedyBear",
    request=inline_serializer(
        name="EnrichmentSerializerRequest",
        fields={"query": rfs.CharField()},
    ),
    responses={
        200: inline_serializer(
            name="EnrichmentSerializerResponse",
            fields={"found": rfs.BooleanField(), "ioc": IOCSerializer},
        ),
    },
)
@api_view([GET])
@authentication_classes([CookieTokenAuthentication])
@permission_classes([IsAuthenticated])
def enrichment_view(request):
    observable_name = request.query_params.get("query")
    logger.info(f"Enrichment view requested for: {str(observable_name)}")
    serializer = EnrichmentSerializer(data=request.query_params, context={"request": request})
    serializer.is_valid(raise_exception=True)

    source_ip = str(request.META["REMOTE_ADDR"])
    request_source = Statistics(source=source_ip, view=viewType.ENRICHMENT_VIEW.value)
    request_source.save()

    return Response(serializer.data, status=status.HTTP_200_OK)


class StatisticsViewSet(viewsets.ViewSet):
    @action(detail=True, methods=["GET"])
    def feeds(self, request, pk=None):
        if pk == "sources":
            annotations = {"Sources": Count("source", distinct=True, filter=Q(view=viewType.FEEDS_VIEW.value))}
        elif pk == "downloads":
            annotations = {"Downloads": Count("source", filter=Q(view=viewType.FEEDS_VIEW.value))}
        else:
            logger.error("this is impossible. check the code")
            return HttpResponseServerError()
        return self.__aggregation_response_static_statistics(annotations)

    @action(detail=True, methods=["get"])
    def enrichment(self, request, pk=None):
        if pk == "sources":
            annotations = {
                "Sources": Count(
                    "source",
                    distinct=True,
                    filter=Q(view=viewType.ENRICHMENT_VIEW.value),
                )
            }
        elif pk == "requests":
            annotations = {"Requests": Count("source", filter=Q(view=viewType.ENRICHMENT_VIEW.value))}
        else:
            logger.error("this is impossible. check the code")
            return HttpResponseServerError()
        return self.__aggregation_response_static_statistics(annotations)

    @action(detail=False, methods=["get"])
    def feeds_types(self, request):
        # FEEDS
        annotations = {
            "Log4j": Count("name", filter=Q(log4j=True)),
            "Cowrie": Count("name", filter=Q(cowrie=True)),
        }
        # feed_type for each general honeypot in the list
        generalHoneypots = GeneralHoneypot.objects.all().filter(active=True)
        for hp in generalHoneypots:
            annotations[hp.name] = Count("name", Q(general__icontains=hp.name.lower()))
        return self.__aggregation_response_static_ioc(annotations)

    def __aggregation_response_static_statistics(self, annotations: dict) -> Response:
        delta, basis = self.__parse_range(self.request)
        qs = Statistics.objects.filter(request_date__gte=delta).annotate(date=Trunc("request_date", basis)).values("date").annotate(**annotations)
        return Response(qs)

    def __aggregation_response_static_ioc(self, annotations: dict) -> Response:
        delta, basis = self.__parse_range(self.request)
        qs = IOC.objects.filter(last_seen__gte=delta).annotate(date=Trunc("last_seen", basis)).values("date").annotate(**annotations)
        return Response(qs)

    @staticmethod
    def __parse_range(request):
        try:
            range_str = request.GET["range"]
        except KeyError:
            # default
            range_str = "7d"

        return parse_humanized_range(range_str)


@api_view([GET])
@authentication_classes([CookieTokenAuthentication])
@permission_classes([IsAuthenticated])
def checkAuthentication(request):
    logger.info(f"User: {request.user}, Administrator: {request.user.is_superuser}")
    return Response({"is_superuser": request.user.is_superuser}, status=status.HTTP_200_OK)


TokenSessionsViewSet = durin_views.TokenSessionsViewSet
APIAccessTokenView = durin_views.APIAccessTokenView
